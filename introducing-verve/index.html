<!DOCTYPE html><html lang="en" class="astro-ZRE6QY23"><head>
    
<!-- Global Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="shortcut icon" type="image/png" href="/blog/favicon.ico">

<!-- Primary Meta Tags -->
<title>Introducing Verve by Tadeu Zagallo</title>
<meta name="title" content="Introducing Verve by Tadeu Zagallo">
<meta name="description" content="An experimental, minimalistic, static, functional language with zero dependencies.">

<!-- Open Graph / Facebook -->
<meta property="og:title" content="Introducing Verve by Tadeu Zagallo">
<meta property="og:type" content="article">
<meta property="og:url" content="https://tadeuzagallo.com/blog/introducing-verve/">
<meta property="og:description" content="An experimental, minimalistic, static, functional language with zero dependencies.">
<meta property="og:image" content="https://tadeuzagallo.com/blog/images/verve-logo.jpg">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://tadeuzagallo.com/blog/introducing-verve/">
<meta property="twitter:title" content="Introducing Verve by Tadeu Zagallo">
<meta property="twitter:description" content="An experimental, minimalistic, static, functional language with zero dependencies.">
<meta property="twitter:image" content="https://tadeuzagallo.com/blog/images/verve-logo.jpg">
<meta property="twitter:site" content="@tadeuzagallo">

<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap" rel="stylesheet">

<!-- Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-47264623-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-47264623-1');
</script>

<link rel="stylesheet" href="../assets/blog.0106c48b.css"><link rel="stylesheet" href="../assets/code.28b7c1f4.css"><link rel="stylesheet" href="../assets/index.aa768e43.css">

		

    
  </head>
  <body>
    <div class="wrapper astro-ZRE6QY23">
      <a class="gohome astro-ZRE6QY23" href="/blog/">All posts</a>
      <div class="blog-post astro-ZRE6QY23">
        <header class="header astro-ZRE6QY23">
          <h1 class="astro-ZRE6QY23">Introducing Verve</h1>
          <p class="desc astro-ZRE6QY23">An experimental, minimalistic, static, functional language with zero dependencies.</p>
          <time class="date-published astro-ZRE6QY23" datetime="July 8, 2016">
            8 Jul 2016
          </time>
        </header>

        <div class="blog-post-text astro-ZRE6QY23">
          <p>I make no secret that I have been working on a programming language for quite a while, and now that I found a name for it, I can finally make it open source!</p>
<h2 id="but-first-of-all-why-am-i-writing-this-language">But first of all, why am I writing this language?</h2>
<p>The short answer is: For fun.</p>
<p>The long answer is that I’ve been interested in compilers for a while, but I have always needed to put things in practice in order to properly understand them, and this is my playground where I can try all the cool stuff that I did and will learn about programming language and compiler design.</p>
<p>As a result, everything in <a href="https://github.com/tadeuzagallo/verve-lang">Verve</a> is written from scratch, it has zero dependencies and I plan to keep it like that. One of the first things I usually hear is “Why don’t you target <a href="http://llvm.org">LLVM</a>?” (or some other runtime), and the answer is: because that wouldn’t be as much fun. Sure, it’d be much easier to get “production ready” that way, but as I said, the goal here is really to learn and have fun.</p>
<h2 id="what-does-it-look-like">What does it look like?</h2>
<p>My goals for <a href="https://github.com/tadeuzagallo/verve-lang">Verve</a> as a language are not really novel: creating a more approachable functional language. There are concepts and syntax borrowed from many other languages, both major and minor, functional and object-oriented, and although Verve is fully functional, the idea is to keep a certain balance amongst these concepts in order to create a nice and approachable language.</p>
<p>The basic syntax for function declaration and invocation might (incidentally) resemble <a href="https://www.rust-lang.org">Rust</a>:</p>
<pre class="language-rust"><code data-astro-raw="" class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> int <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> n
  <span class="token keyword">else</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Here the <code data-astro-raw="">fn</code> keyword indicates it’s a function declaration, and every function must have explicit types for its parameters and return type. Everything in Verve is an expression, which means that you can do things like assign an <code data-astro-raw="">if</code> expression to a variable.</p>
<p>Additionally, there’s no support for explicit returns, the return value of a function is the result of the last expression in its body.</p>
<p>The semantics and syntax for function calls pretty much match every C-style languages: you must pass the right number of arguments, of the right type, separated by commas and in between parenthesis.</p>
<p>Verve has <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic Data Types</a> (ADT) and pattern matching:</p>
<pre class="language-rust"><code data-astro-raw="" class="language-rust"><span class="token keyword">type</span> list<span class="token operator">&lt;</span>t<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token class-name">Nil</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token class-name">Cons</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> list<span class="token operator">&lt;</span>t<span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>Here we define the recursive type <code data-astro-raw="">list</code>, that takes the type variable <code data-astro-raw="">t</code>, which represents what type this list will contain. The <code data-astro-raw="">list</code> type has two type constructors (which <em>construct</em> instances of a type), <code data-astro-raw="">Nil</code> and <code data-astro-raw="">Cons</code>.</p>
<p>Once you have constructed a type, the only way to extract its contents is to pattern <code data-astro-raw="">match</code> it:</p>
<pre class="language-rust"><code data-astro-raw="" class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">print_list</span><span class="token punctuation">(</span>l<span class="token punctuation">:</span> list<span class="token operator">&lt;</span>printable<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> void <span class="token punctuation">{</span>
  <span class="token keyword">match</span> l <span class="token punctuation">{</span>
    <span class="token class-name">Nil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token class-name">Cons</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> rest<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
      <span class="token function">print_list</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>(you can also use pattern match with <code data-astro-raw="">let</code> expressions)</p>
<p><a href="https://github.com/tadeuzagallo/verve-lang">Verve</a> also has type <code data-astro-raw="">interfaces</code> and <code data-astro-raw="">implementations</code>, which semantically are pretty similar to <a href="https://www.haskell.org/tutorial/classes.html">Haskell</a>’s type classes and instances:</p>
<pre class="language-rust"><code data-astro-raw="" class="language-rust">interface show<span class="token operator">&lt;</span>t<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> <span class="token function">show</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> string
<span class="token punctuation">}</span>

implementation show<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">fn</span> <span class="token function-definition function">show</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> s <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>The <code data-astro-raw="">interface</code> takes a type variable, representing any type that will implement this interface, and can declare both <code data-astro-raw="">virtual</code> and concrete functions. For <code data-astro-raw="">virtual</code> functions you only need to specify the signature, and it <em>must</em> be overridden  on every <code data-astro-raw="">implementation</code>.  Concrete functions are declared as common functions, with types and a body, and <em>may</em> be overridden on any <code data-astro-raw="">implementation</code>.</p>
<p>Another characteristic of <a href="https://github.com/tadeuzagallo/verve-lang">Verve</a> is that, even though you can’t write any side effects with the language’s semantics, you can still write a function with side effects in C/C++ and <code data-astro-raw="">extern</code> it. Like print:</p>
<pre class="language-rust"><code data-astro-raw="" class="language-rust"><span class="token keyword">extern</span> <span class="token function">print</span> <span class="token punctuation">(</span>printable<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> void</code></pre>
<p>It takes a value of any type that implements the interface <code data-astro-raw="">printable</code> and returns <code data-astro-raw="">void</code>, but it’s implementation in C++ writes to the standard output, which is a side effect of the function invocation.</p>
<p>This are the base concepts of the language, next I’ll talk a little bit about how and why it’s implemented the way it is.</p>
<h2 id="the-implementation">The implementation</h2>
<p>Right now <a href="https://github.com/tadeuzagallo/verve-lang">Verve</a> runs on its own <a href="https://en.wikipedia.org/wiki/Virtual_machine">Virtual Machine</a> (VM), which is something that is no longer necessary: When I started what became the current implementation, I didn’t really want to write a language, I just wanted to write a VM, but I needed something to run on it and I was too lazy to write a proper parser, so I just started off with some very basic lisp.</p>
<p>As I worked on the VM, I started using the language for tests and sample code, and I didn’t really like it, so I started spending more time in making it a better language than on the VM itself, and now I have a statically typed language, where we can know all the types at compile time, and for which it should be rather straightforward to generate machine code ahead of time given that we already generate bytecode.</p>
<p>I’ll talk briefly about 5 pieces of the implementation: Parser, Type checker, Bytecode, Interpreter and Garbage Collector.</p>
<h3 id="parser">Parser</h3>
<p>The parser is a handwritten <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a>. The grammar is <a href="https://en.wikipedia.org/wiki/LL_grammar">LL(1)</a>, and can be found <a href="https://github.com/tadeuzagallo/verve-lang/blob/master/resources/grammar.ebnf">here</a>.</p>
<p>Fun fact about the grammar: I wrote the parser before writing the grammar, and started running into many issues, then decided to sit down and write the formal grammar, and found many bugs on the code I had written for the tests.</p>
<h3 id="type-checker">Type checker</h3>
<p>The type checker is not very sophisticated: since type annotations are mandatory for functions, we only have to <a href="https://en.wikipedia.org/wiki/Type_inference">infer</a> types for local variables, which in turn are immutable.</p>
<h3 id="bytecode">Bytecode</h3>
<p>Verve’s VM is a <a href="https://en.wikipedia.org/wiki/Stack_machine">stack machine</a> and has its own bytecode, which is tiny, only 23 opcodes. It was designed for simplicity over efficiency, and I plan on replacing it with a register based bytecode, before actually generating machine code.</p>
<h3 id="interpreter">Interpreter</h3>
<p>The interpreter is probably the part of the VM which I’m most proud of: It’s written in <a href="https://en.wikipedia.org/wiki/GNU_Assembler">GAS</a> x86_64, and inspired by <a href="http://trac.webkit.org/wiki/JavaScriptCore">JavaScriptCore</a>’s LLInt (Low Level Interpreter), with a few modifications:
Since the code is platform dependant, I can abuse of all x86_64’s registers.
When it comes to <a href="https://en.wikipedia.org/wiki/Inline_caching">inline caching</a>, LLInt’s bytecode contains “holes” for variable values, which will later be rewritten into the actual value loaded from the variable. In Verve I opted not to that because it requires modifying the bytecode itself, which will cause memory pages to be copied, and instead I use a side table for storing the values and only add a fixed index into the table to bytecode itself.</p>
<h3 id="garbage-collection-gc">Garbage Collection (GC)</h3>
<p>As the opposite of the interpreter, the <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">GC</a> is probably the part of the system that received the least love. It just uses the C++ heap and keeps track of allocations’ address and size in a separate structure. When a garbage collection is triggered, the collector stops the world and scans the stack conservatively and the heap precisely, then eagerly sweeps everything in one pass.</p>
<p>These are the basics of how the key parts of the current implementation work, but as you’ll see next, it might change soon.</p>
<h2 id="what-next">What Next?</h2>
<p>The next major goal is making the language <a href="https://en.wikipedia.org/wiki/Self-hosting">self-hosting</a> (i.e. write the Verve compiler in Verve itself), and that depends on several smaller things, such as converting bytecode/<a href="https://en.wikipedia.org/wiki/Intermediate_representation">IR</a> to be register based, getting rid of the interpreter and replacing it with an <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT</a> compiler, and definitely minor improvements of the language, such as adding more <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a> and making pattern matching more powerful than it currently is.</p>
<hr>
<p>I hope you enjoyed the post, and if you think you’d have fun with <a href="https://github.com/tadeuzagallo/verve-lang">Verve</a> as well, either playing with the language or the implementation, the code can be found at <a href="https://github.com/tadeuzagallo/verve-lang">github.com/tadeuzagallo/verve-lang</a></p>
<small>
<em>As usual I try to keep links to every possible acronym and term that I think could be new for <strong>anyone</strong> reading the post, but of course I might have forgotten some. So if you had to google for any of the terms in the text, please let me know and I’ll add a reference to it. Thanks!</em>
</small>
        </div>

        <footer class="footer astro-ZRE6QY23">
          <section class="share astro-ZRE6QY23">
            <button class="share-button astro-ZRE6QY23" aria-label="Share on Twitter" title="Share on Twitter">
              <svg class="share-icon astro-ZRE6QY23" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg">
                <path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z" class="astro-ZRE6QY23"></path>
              </svg>
              <span class="astro-ZRE6QY23">Share on Twitter</span>
            </button>
          </section>

          <div id="disqus_thread" class="astro-ZRE6QY23"></div>

          <script data-title="Introducing Verve" data-slug="introducing-verve" data-permalink="https://tadeuzagallo.com/blog/introducing-verve/">
            const { title, slug, permalink } = document.currentScript.dataset;
            var disqus_config = function () {
              this.page.title = title;
              this.page.identifier = slug;
              this.page.url = permalink; 
            };
            (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://tadeuzagallo.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
            })();
          </script>
          <script data-twitterurl="https://twitter.com/intent/tweet?text=&quot;Introducing Verve: An experimental, minimalistic, functional language with zero dependencies&quot; https://tadeuzagallo.com/blog/introducing-verve/ via @tadeuzagallo&amp;hashtags=verve,fp,interpreter">
            const { twitterurl } = document.currentScript.dataset;
            document.querySelector('.share-button').addEventListener('click', e => {
              e.preventDefault();
              window.open(twitterurl, 'twitter-share', 'width=800,height=800');
            });
          </script>
        </footer>
      </div>
    </div>
  


</body></html>