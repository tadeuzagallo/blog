<!DOCTYPE html><html lang="en" class="astro-ZRE6QY23"><head>
    
<!-- Global Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="shortcut icon" type="image/png" href="/blog/favicon.ico">

<!-- Primary Meta Tags -->
<title>Pretty Typing by Tadeu Zagallo</title>
<meta name="title" content="Pretty Typing by Tadeu Zagallo">
<meta name="description" content="Pretty-printing meets type inference">

<!-- Open Graph / Facebook -->
<meta property="og:title" content="Pretty Typing by Tadeu Zagallo">
<meta property="og:type" content="article">
<meta property="og:url" content="https://tadeuzagallo.com/blog/pretty-typing/">
<meta property="og:description" content="Pretty-printing meets type inference">
<meta property="og:image" content="https://tadeuzagallo.com/blog/images/logo.jpg">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://tadeuzagallo.com/blog/pretty-typing/">
<meta property="twitter:title" content="Pretty Typing by Tadeu Zagallo">
<meta property="twitter:description" content="Pretty-printing meets type inference">
<meta property="twitter:image" content="https://tadeuzagallo.com/blog/images/logo.jpg">
<meta property="twitter:site" content="@tadeuzagallo">

<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap" rel="stylesheet">

<!-- Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-47264623-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-47264623-1');
</script>

<link rel="stylesheet" href="../assets/blog.0106c48b.css"><link rel="stylesheet" href="../assets/code.28b7c1f4.css"><link rel="stylesheet" href="../assets/index.aa768e43.css">

		

    
  </head>
  <body>
    <div class="wrapper astro-ZRE6QY23">
      <a class="gohome astro-ZRE6QY23" href="/blog/">All posts</a>
      <div class="blog-post astro-ZRE6QY23">
        <header class="header astro-ZRE6QY23">
          <h1 class="astro-ZRE6QY23">Pretty Typing</h1>
          <p class="desc astro-ZRE6QY23">Pretty-printing meets type inference</p>
          <time class="date-published astro-ZRE6QY23" datetime="May 25, 2017">
            25 May 2017
          </time>
        </header>

        <div class="blog-post-text astro-ZRE6QY23">
          <p>Today I was reading <a href="https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html">this great post on the Rust blog</a> about the ergonomics initiative by the Rust language team. It includes a great discussion around ‚Äúimplicit vs explicit‚Äù, and some ideas for finding the right balance so that a language is not too verbose and yet it‚Äôs easy to understand for people reading the code.</p>
<p>I really enjoyed the post, and it got me thinking: the code I‚Äôd like to write is not necessarily the same code I‚Äôd like to read.</p>
<h3 id="pretty-printing">Pretty-printing</h3>
<p>Enforcing a consistent coding style can be seen to have similar trade-offs: when you‚Äôre writing code or (more critically) moving code around you don‚Äôt want to be slowed down by manually formatting your code so that it looks nice, but it‚Äôs also terrible to review code that‚Äôs poorly formatted or to work on a codebase that doesn‚Äôt have a consistent coding style.</p>
<p>It is a similar dilemma: should you optimise for the writer and just let them format their code however is more productive for them <strong>or</strong> should you optimise for the people who are reading the code and have a consistent style?</p>
<p>Many people would argue for the latter, as in most cases the code written by a single person will be read by more than one person. However, smart formatters such as <a href="https://blog.golang.org/go-fmt-your-code">gofmt</a>, <a href="https://facebook.github.io/reason/tools.html#tools-command-line-utilities-refmt">refmt</a> and <a href="http://jlongster.com/A-Prettier-Formatter">prettier</a> have had great success by automating this process out of the users way, showing that this might be a false dichotomy.</p>
<!--### Pretty-typing-->
<h3 id="pretty-typing">Pretty-<em>typing</em></h3>
<p>Maybe we could apply similar ideas to other areas of coding, such as type inference?</p>
<p>When you start working on a project or a feature you build a mental model of it as you go, and so you require little to no context about the code you‚Äôre working on. As soon as you page out that code from your mind, or when someone else looks at your code, that is no longer true though.</p>
<p>Extrapolating a little bit, consider Google Docs as an example: You have an ‚Äúediting mode‚Äù for when you are writing, a ‚Äúsuggesting mode‚Äù for when you are reviewing a document and a ‚Äúviewing mode‚Äù for when you‚Äôre just reading it. All this modes are slightly different, optimised for the task at hand.</p>
<p><strong>What if we had an ‚Äúediting mode‚Äù and a ‚Äúviewing mode‚Äù for coding?</strong></p>
<!--Compilers can be quite smart, and they do know a lot about your program, which means that they can infer many things that we'd otherwise have to type, but whoever reads that code afterwards will have to do the same job as the compiler to understand everything that is implicit.-->
<p>When writing code you could benefit from everything the compiler knows about your program: if something can be inferred, you should not be <em>required</em> to type it.</p>
<p>On the other hand, working on other people‚Äôs code is known to be challenging, specially when you‚Äôre new to a codebase. This could be eased by adding extra information known to the compiler right next to the code, more specifically consistent type annotations.</p>
<!--But what if what you type wasn‚Äôt necessarily what your coworkers are going to read? You could just use all the knowledge the compiler has about your code, and in the end we could just "pretty-type" it, optimising for readability.-->
<!--Sure, you could argue that good IDE support comes close to that, as it allows you to query the types of any expressions and jump through code, but not just that requires interaction with IDE restricts what users can use to write programs in your language.-->
<p>Sure, you can already achieve some of it with a good IDE today: it allows you to query the type of any expression, jump through code, define snippets and etc. The problem I see with that is not just that it requires an extra step to interact with the IDE, but anyone who‚Äôs favourite environment is not supported will have to make a choice: either you switch to a supported environment or you take a productivity hit.</p>
<h3 id="example">Example</h3>
<p>Here‚Äôs what I imagine it could look like in <a href="https://tadeuzagallo.com/blog/introducing-verve/">Verve</a>, my personal language project. You start prototyping your program, and you don‚Äôt want to spend too much time writing types, so you take full advantage of type inference.</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">fn map(fn, list) {
  match list {
    case [x, ...rest]: [fn(x), ...map(fn, rest)],
    case []: [],
  }
}</code></pre>
<p>And once you pretty-print your program it could look like the following.</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">/// maybe include a header doc template if it's part of the public API?
fn map&lt;T, U&gt;(fn: (T) -&gt; U, list: List&lt;T&gt;) -&gt; List&lt;U&gt; {
  match list {
    case [x, ...rest]: [fn(x), ...map(fn, rest)],
    case []: [],
  }
}</code></pre>
<p>This way other people‚Äôs productivity is not affected by the fact that you took full advantage of type inference. They have the full type of the function right next to it regardless of whether you typed it or not.</p>
<h3 id="further-advantages">Further advantages</h3>
<p>Another thing that jumped to mind was that it ensures whoever modifies this code next will have clear feedback of how their changes affect the API.</p>
<p>For example, if you decided to do some print-debug in the untyped <code data-astro-raw="">map</code> function above, such as:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">fn map(fn, list) {
  match list {
    case [x, ...rest]:
      print_string(x)
      [fn(x), ...map(fn, rest)],
    case []: [],
  }
}</code></pre>
<p>This would cause <code data-astro-raw="">list</code> to have an inferred type of <code data-astro-raw="">List&lt;String&gt;</code> instead of a generic list. To make things worse, this will fail not within <code data-astro-raw="">map</code>, but later on based on types inferred by calls to <code data-astro-raw="">map</code> (it might unify some other type with<code data-astro-raw="">List&lt;String&gt;</code> and fail in a seemingly unrelated part of the codebase).</p>
<p>Sure, you could add explicit types to <code data-astro-raw="">map</code> in order to prevent it, but that invalidates the whole point of this post. Additionally, if you just typed this function and have full context of what the program is doing, that might be tolerable, but if you‚Äôre just getting started in the codebase I believe this could be frustrating.</p>
<p>This is purely based on my personal experience: when this happens to me I mostly end up manually writing the types to get a better understanding of where things went wrong, hence why I believe this could be helpful.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Functional languages such as OCaml and Haskell already have great type inference and support explicit type annotations, but it‚Äôs still up to the programmer to manually write the type annotations. It would be great if we could take it a step further and do for type inference (and maybe more than types?) what formatters did for coding style.</p>
<p>As a final remark, nothing that I mentioned here has actually been implemented in Verve yet, but I thought I‚Äôd write it down anyway, so maybe someone can stop me in time if it‚Äôs a bad idea.</p>
<p>Thanks for reading! üòÄ</p>
        </div>

        <footer class="footer astro-ZRE6QY23">
          <section class="share astro-ZRE6QY23">
            <button class="share-button astro-ZRE6QY23" aria-label="Share on Twitter" title="Share on Twitter">
              <svg class="share-icon astro-ZRE6QY23" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg">
                <path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z" class="astro-ZRE6QY23"></path>
              </svg>
              <span class="astro-ZRE6QY23">Share on Twitter</span>
            </button>
          </section>

          <div id="disqus_thread" class="astro-ZRE6QY23"></div>

          <script data-title="Pretty Typing" data-slug="pretty-typing" data-permalink="https://tadeuzagallo.com/blog/pretty-typing/">
            const { title, slug, permalink } = document.currentScript.dataset;
            var disqus_config = function () {
              this.page.title = title;
              this.page.identifier = slug;
              this.page.url = permalink; 
            };
            (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://tadeuzagallo.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
            })();
          </script>
          <script data-twitterurl="https://twitter.com/intent/tweet?text=&quot;Pretty Typing: Pretty-printing meets type inference&quot; https://tadeuzagallo.com/blog/pretty-typing/ via @tadeuzagallo&amp;hashtags=programming-languages,fp">
            const { twitterurl } = document.currentScript.dataset;
            document.querySelector('.share-button').addEventListener('click', e => {
              e.preventDefault();
              window.open(twitterurl, 'twitter-share', 'width=800,height=800');
            });
          </script>
        </footer>
      </div>
    </div>
  


</body></html>