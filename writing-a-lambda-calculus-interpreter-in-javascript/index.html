<!DOCTYPE html><html lang="en" class="astro-ZRE6QY23"><head>
    
<!-- Global Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="shortcut icon" type="image/png" href="/blog/favicon.ico">

<!-- Primary Meta Tags -->
<title>A λ-calculus interpreter by Tadeu Zagallo</title>
<meta name="title" content="A λ-calculus interpreter by Tadeu Zagallo">
<meta name="description" content="in less than 300 lines of JavaScript">

<!-- Open Graph / Facebook -->
<meta property="og:title" content="A λ-calculus interpreter by Tadeu Zagallo">
<meta property="og:type" content="article">
<meta property="og:url" content="https://tadeuzagallo.com/blog/writing-a-lambda-calculus-interpreter-in-javascript/">
<meta property="og:description" content="in less than 300 lines of JavaScript">
<meta property="og:image" content="https://tadeuzagallo.com/blog/images/logo.jpg">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://tadeuzagallo.com/blog/writing-a-lambda-calculus-interpreter-in-javascript/">
<meta property="twitter:title" content="A λ-calculus interpreter by Tadeu Zagallo">
<meta property="twitter:description" content="in less than 300 lines of JavaScript">
<meta property="twitter:image" content="https://tadeuzagallo.com/blog/images/logo.jpg">
<meta property="twitter:site" content="@tadeuzagallo">

<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap" rel="stylesheet">

<!-- Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-47264623-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-47264623-1');
</script>

<link rel="stylesheet" href="../assets/blog.0106c48b.css"><link rel="stylesheet" href="../assets/code.28b7c1f4.css"><link rel="stylesheet" href="../assets/index.aa768e43.css">

		

    
  </head>
  <body>
    <div class="wrapper astro-ZRE6QY23">
      <a class="gohome astro-ZRE6QY23" href="/blog/">All posts</a>
      <div class="blog-post astro-ZRE6QY23">
        <header class="header astro-ZRE6QY23">
          <h1 class="astro-ZRE6QY23">A λ-calculus interpreter</h1>
          <p class="desc astro-ZRE6QY23">in less than 300 lines of JavaScript</p>
          <time class="date-published astro-ZRE6QY23" datetime="February 3, 2017">
            3 Feb 2017
          </time>
        </header>

        <div class="blog-post-text astro-ZRE6QY23">
          <p><em>Note:</em> this is a big refactor of a previous post. I was planning on making this into a series, when I realised that first I had to make some improvements to this initial post to have a better structure. Well, this is the result, and I hope you enjoy. Alternatively, the original version can be found <a href="/blog/writing-a-lambda-calculus-interpreter-in-javascript-original/">here</a>.</p>
<p>I had heard about lambda calculus, but it wasn’t until <a href="https://twitter.com/tadeuzagallo/status/742836038264098817">recently</a>, when I started reading <a href="https://www.cis.upenn.edu/~bcpierce/tapl">Types and Programming Languages</a>, that I could really see the beauty of it. So simple, and yet so powerful.</p>
<p>In fact, it’s such a simple language that its full implementation fits in a single article, which makes it great to learn/teach the basics of interpretation.</p>
<p>But before we start, what is lambda calculus anyway? Here’s the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">Wikipedia</a> description:</p>
<blockquote>
<p>Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution. It is a universal model of computation that can be used to simulate any single-taped Turing machine and was first introduced by mathematician Alonzo Church in the 1930s as part of an investigation into the foundations of mathematics.</p>
</blockquote>
<p>And to illustrate, here’s what a very simple λ-calculus program might look like:</p>
<pre class="language-haskell"><code data-astro-raw="" class="language-haskell"><span class="token punctuation">(</span>λ<span class="token hvariable">x</span><span class="token punctuation">.</span> λ<span class="token hvariable">y</span><span class="token punctuation">.</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>λ<span class="token hvariable">y</span><span class="token punctuation">.</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>λ<span class="token hvariable">x</span><span class="token punctuation">.</span> <span class="token hvariable">x</span><span class="token punctuation">)</span></code></pre>
<p>You only have two constructs in λ-calculus: Function abstractions (i.e. a lambda expression) and applications (i.e. function calls), and yet, you can perform any computation with it!</p>
<h2 id="1-structure">1. Structure</h2>
<p>An interpreter takes the source code of a program and executes it. In order to transform the program string into an executable format the interpreter has to do a lot of work, and this work is usually organised into <em>phases</em>. Compilers and interpreters might have many phases, ours will have two:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Lexical_analysis">Lexical analysis</a>: The lexical analyser (or lexer for short) breaks sequences of characters into meaningful tokens, e.g. the input <code data-astro-raw="">x</code> will result into a identifier token (<code data-astro-raw="">LCID</code> in our case), with the semantic value <code data-astro-raw="">"x"</code> associated to it.</li>
<li><a href="https://en.wikipedia.org/wiki/Parsing">Syntactic analysis</a>: The syntax analyser (or parser for short) consumes the tokens generated by the lexer, verifies if the input is correct according to the source language’s syntax and builds an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> (AST).</li>
</ul>
<p>In addition, there are many <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)#Variations">kinds of interpreters</a>, we’ll write an AST interpreter, as we can take the result of our lexical analysis and feed it directly into the interpreter. Other kinds of interpreters will require extra phase(s) to transform the AST into the interpreter’s input format.</p>
<h2 id="2-grammar">2. Grammar</h2>
<p>Before writing a parser, the first thing we need to define is the grammar for the language we’ll be parsing, here’s the <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> grammar for the λ-calculus:</p>
<pre class="language-bnf"><code data-astro-raw="" class="language-bnf">term <span class="token operator">::=</span> application
       <span class="token operator">|</span> LAMBDA LCID DOT term

application <span class="token operator">::=</span> application atom
              <span class="token operator">|</span> atom

atom <span class="token operator">::=</span> LPAREN term RPAREN
       <span class="token operator">|</span> LCID</code></pre>
<h3 id="21-structure-of-the-grammar">2.1. Structure of the grammar</h3>
<p>The <em>grammar</em> consists of a set of <em>productions</em>.</p>
<p>A <em>production</em> is a substitution rule: it indicates that we can replace its <em>left-hand side</em> with its <em>right-hand side</em>.</p>
<p>The <em>left-hand side</em> of a production consists of a single <em>nonterminal</em>.</p>
<p>The <em>right-hand</em> side of a production consists of one or more <em>alternative</em> substitutions separated by pipes ( <code data-astro-raw="">|</code> ).</p>
<p>An <em>alternative</em> is any sequence of zero or more <em>terminals</em> and <em>nonterminals</em>.</p>
<p><em>Nonterminals</em> appear in lowercase and are used to refer to the <em>right-hand side</em> of the production where it was defined.</p>
<p><em>Terminals</em> appear in uppercase and represent some pattern in the actual text input.</p>
<h3 id="22-understanding-the-grammar">2.2. Understanding the grammar</h3>
<p>The grammar starts with a <code data-astro-raw="">term</code>, as it’s the first rule of the grammar.</p>
<p>A <code data-astro-raw="">term</code> might consist of either an <code data-astro-raw="">application</code> or an <code data-astro-raw="">abstraction</code> (defined inline).</p>
<p>An <code data-astro-raw="">application</code> can be made of either another <code data-astro-raw="">application</code> followed by an <code data-astro-raw="">atom</code> or alternatively by a single <code data-astro-raw="">atom</code>. This is a left-recursive rule (recursive because it refers to itself, left-recursive because the recurring term appears in the first position), which means that it’s left-associative (i.e. an application with the form <code data-astro-raw="">a b c</code>, should be grouped as <code data-astro-raw="">(a b) c</code> rather than <code data-astro-raw="">a (b c)</code>).</p>
<p><code data-astro-raw="">atoms</code> can either be a lowercase identifier (<code data-astro-raw="">LCID</code>) or a <code data-astro-raw="">term</code> wrapped in parentheses (for disambiguation).</p>
<h2 id="3-tokens">3. Tokens</h2>
<p>The terminals in the grammar are exactly the tokens that our lexer has to produce (and that later our parse will consume). Here are the rules for creating each token:</p>
<pre class="language-javascript"><code data-astro-raw="" class="language-javascript"><span class="token constant">LPAREN</span><span class="token operator">:</span> <span class="token string">'('</span>
<span class="token constant">RPAREN</span><span class="token operator">:</span> <span class="token string">')'</span>
<span class="token constant">LAMBDA</span><span class="token operator">:</span> <span class="token string">'λ'</span> <span class="token comment">/* we'll also allow `\` for convenience */</span>
<span class="token constant">DOT</span><span class="token operator">:</span> <span class="token string">'.'</span>
<span class="token comment">// lowercase identifier: lowercase letter followed by any letters</span>
<span class="token constant">LCID</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z][a-zA-Z]*</span><span class="token regex-delimiter">/</span></span></code></pre>
<p>To represent the tokens we’ll create <code data-astro-raw="">Token</code> class to hold the <code data-astro-raw="">type</code> (one of the above) and an optional semantic value (e.g. the string matched by <code data-astro-raw="">LCID</code>).</p>
<pre class="language-javascript"><code data-astro-raw="" class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Token</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h2 id="4-lexer">4. Lexer</h2>
<p>Now we can use the tokens defined above to write a <code data-astro-raw="">Lexer</code>, providing a nice API for the parser to consume the tokens.</p>
<p>The token creation part of the Lexer is not very exciting: it’s one big switch statement that checks the next char in the source code:</p>
<pre class="language-javascript"><code data-astro-raw="" class="language-javascript"><span class="token function">_nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'λ'</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token string">'\\'</span><span class="token operator">:</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_token <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Token</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LAMBDA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> <span class="token string">'.'</span><span class="token operator">:</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_token <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Token</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">DOT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> <span class="token string">'('</span><span class="token operator">:</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_token <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Token</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LPAREN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>The lexer will provide the following API for the parser:</p>
<ul>
<li><code data-astro-raw="">next(t)</code>: returns a boolean indicating whether the next token is of type <code data-astro-raw="">t</code>;</li>
<li><code data-astro-raw="">skip(t)</code>: same as <code data-astro-raw="">next</code>, but skips the token if it matches;</li>
<li><code data-astro-raw="">match(t)</code>: assert that <code data-astro-raw="">next</code> is true, and <code data-astro-raw="">skip</code>;</li>
<li><code data-astro-raw="">token(t)</code>: assert that <code data-astro-raw="">next</code> is true, and return the token’s semantic value.</li>
</ul>
<p>Okay, now to the <code data-astro-raw="">Parser</code>!</p>
<h2 id="5-parser">5. Parser</h2>
<p>Before we start writing the parser, there’s only one tricky bit about this grammar: handwritten parsers are usually <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent</a> (the one we’re writing will be), and they can’t handle <a href="https://en.wikipedia.org/wiki/Left_recursion">left recursion</a>.</p>
<p>But luckily left recursions can be removed with <a href="https://en.wikipedia.org/wiki/Left_recursion#Removing_left_recursion">one simple trick</a>:</p>
<p>We take the original production…</p>
<pre class="language-bnf"><code data-astro-raw="" class="language-bnf">application <span class="token operator">::=</span> application atom
              <span class="token operator">|</span> atom</code></pre>
<p>…and break it into two:</p>
<pre class="language-bnf"><code data-astro-raw="" class="language-bnf">application <span class="token operator">::=</span> atom application'

application<span class="token string">' ::= atom application'</span>
               <span class="token operator">|</span> ε  /<span class="token operator">*</span> empty <span class="token operator">*</span>/</code></pre>
<p>Now we have a right-recursive rule which can only expand <code data-astro-raw="">application'</code> while there’s another <code data-astro-raw="">atom</code> next, otherwise we choose the alternative right-hand side (<code data-astro-raw="">ε</code>) which matches nothing, i.e. we stop.</p>
<p>When implementing the parser we just have to be careful to keep the application rule left-associative, otherwise it will change the order in which the applications are executed and our interpreter will be incorrect.</p>
<h3 id="51-ast">5.1. AST</h3>
<p>From our grammar we can also derive the nodes for our AST: the right-hand side alternatives that have more than one nonterminal or that have any terminals will <em>most of the time</em> require a new node. (The exception in our case is the <code data-astro-raw="">LPAREN term RPAREN</code> alternative, which is simply a <code data-astro-raw="">term</code> wrapped in parentheses, so we just need the <code data-astro-raw="">term</code>.)</p>
<p>We then create three nodes for three alternatives:</p>
<ul>
<li><code data-astro-raw="">Abstraction</code> for <code data-astro-raw="">LAMBDA LCID DOT term</code>, holding <code data-astro-raw="">LCID</code> which is the parameter of the abstraction and <code data-astro-raw="">term</code> which is the body.</li>
<li><code data-astro-raw="">Application</code> for <code data-astro-raw="">application atom</code>, which holds both values as <code data-astro-raw="">lhs</code> and <code data-astro-raw="">rhs</code>.</li>
<li><code data-astro-raw="">Identifier</code> for <code data-astro-raw="">LCID</code>, which holds the parsed lowercase identifier.</li>
</ul>
<p>Here’s a simple program with its AST:</p>
<pre class="language-javascript"><code data-astro-raw="" class="language-javascript"><span class="token punctuation">(</span>λx<span class="token punctuation">.</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span>λy<span class="token punctuation">.</span> y<span class="token punctuation">)</span>

Application <span class="token punctuation">{</span>
  lhs<span class="token operator">:</span> Abstraction <span class="token punctuation">{</span>
    param<span class="token operator">:</span> <span class="token string">'x'</span><span class="token punctuation">,</span>
    body<span class="token operator">:</span> Identifier <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'x'</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  rhs<span class="token operator">:</span> Abstraction <span class="token punctuation">{</span>
    param<span class="token operator">:</span> <span class="token string">'y'</span><span class="token punctuation">,</span>
    body<span class="token operator">:</span> Identifier <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'y'</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="52-parser-implementation">5.2. Parser implementation</h3>
<p>Now that we have our AST nodes, we can use them to construct the actual tree.</p>
<p>We can also derive our parser implementation from the grammar using the following steps:</p>
<ul>
<li>Create one method for each production, named after it’s left-hand side nonterminal.</li>
<li>The body of the method will choose the appropriate alternative based on the next token (i.e. one token of <a href="https://en.wikipedia.org/wiki/Parsing#Lookahead">lookahead</a>).</li>
<li>For each <code data-astro-raw="">x</code> in the chosen alternative:
<ul>
<li>if <code data-astro-raw="">x</code> is a nonterminal, call method <code data-astro-raw="">x</code>;</li>
<li>if <code data-astro-raw="">x</code> is a terminal, consume token <code data-astro-raw="">x</code>.</li>
</ul>
</li>
</ul>
<p>Here’s the actual code:</p>
<pre class="language-javascript"><code data-astro-raw="" class="language-javascript"><span class="token function">term</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// term ::= LAMBDA LCID DOT term</span>
  <span class="token comment">//        | application</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LAMBDA</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">token</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LCID</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">DOT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> term <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">term</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AST<span class="token punctuation">.</span>Abstraction</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> term<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">application</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">application</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// application ::= atom application'</span>
  <span class="token keyword">let</span> lhs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">atom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// application' ::= atom application'</span>
    <span class="token comment">//                | ε</span>
    <span class="token keyword">const</span> rhs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">atom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> lhs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      lhs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AST<span class="token punctuation">.</span>Application</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">atom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// atom ::= LPAREN term RPAREN</span>
  <span class="token comment">//        | LCID</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LPAREN</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> term <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">term</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">RPAREN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">RPAREN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> term<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LCID</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AST<span class="token punctuation">.</span>Identifier</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">token</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LCID</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> id<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="6-evaluation">6. Evaluation</h2>
<p>Now that we have our AST we can use it to evaluate the program.</p>
<p>In order to know how should our interpreter evaluate each construct we first need to look at the λ-calculus’ evaluation rules.</p>
<h3 id="61-evaluation-rules">6.1. Evaluation rules</h3>
<p>First we need to define what are our terms and which of these are values.</p>
<p>We can also derive our terms from the grammar:</p>
<pre class="language-bash"><code data-astro-raw="" class="language-bash">t1 t2   <span class="token comment"># Application</span>

λx. t1  <span class="token comment"># Abstraction</span>

x       <span class="token comment"># Identifier</span></code></pre>
<p>Yes, these are exactly the same as the nodes from our AST! But which are values?</p>
<p>Values are terms that are in its final form, i.e. they can’t be evaluated any further. In this case the only terms that are values are abstractions. (You can’t evaluate a function unless it’s called.)</p>
<p>The actual evaluation rules are as following:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">1)       t1 → t1'
     —————————————————
      t1 t2 → t1' t2


2)       t2 → t2'
     —————————————————
      v1 t2 → v1 t2'


3)    (λx. t12) v2 → [x ↦ v2]t12</code></pre>
<p>Here’s how we can read each rule:</p>
<ol>
<li>If <code data-astro-raw="">t1</code> is a term that evaluates to <code data-astro-raw="">t1'</code>, <code data-astro-raw="">t1 t2</code> will evaluate to <code data-astro-raw="">t1' t2</code>. i.e. the left-hand side of an application is evaluated first.</li>
<li>If <code data-astro-raw="">t2</code> is a term that evaluates to <code data-astro-raw="">t2'</code>, <code data-astro-raw="">v1 t2</code> will evaluate to <code data-astro-raw="">v1 t2'</code>. Notice that the left-hand side is <code data-astro-raw="">v1</code> instead of <code data-astro-raw="">t1</code>, that means that it’s a value and therefore can’t be evaluated any further. i.e. only when we’re done evaluating the left-hand side of the application we’ll start evaluating the right one.</li>
<li>The result of application <code data-astro-raw="">(λx. t12) v2</code> is the same as effectively replacing all occurrences of <code data-astro-raw="">x</code> in <code data-astro-raw="">t12</code> with <code data-astro-raw="">v2</code>. Notice that both sides have to be values before evaluating an application.</li>
</ol>
<h3 id="62-interpreter">6.2. Interpreter</h3>
<p>The interpreter follows the evaluation rules to reduce a program to a value.</p>
<p>All we have to do now is translate the rules above into JavaScript:</p>
<pre class="language-javascript"><code data-astro-raw="" class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">eval</span> <span class="token operator">=</span> <span class="token parameter">ast</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ast <span class="token keyword">instanceof</span> <span class="token class-name">AST<span class="token punctuation">.</span>Application</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValue</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>lhs<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValue</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>rhs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ast <span class="token operator">=</span> <span class="token function">substitute</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>rhs<span class="token punctuation">,</span> ast<span class="token punctuation">.</span>lhs<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValue</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>lhs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ast<span class="token punctuation">.</span>rhs <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        ast<span class="token punctuation">.</span>lhs <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> ast<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><em>NOTE: the original version of this article presented a slightly different version of the <code data-astro-raw="">eval</code> function which stored the variable bindings in a context map. The function was a little bit bigger and less clear, but required less code around it, making the general project simpler. However, there was a bug in the implementation and I decided to switch to the version above, which more closely matches the evaluation rules (and also the version presented in <a href="https://www.cis.upenn.edu/~bcpierce/tapl">TaPL</a>)</em></p>
<p>I hope the correspondence between the evaluation rules and the evaluation function is clear, but in any case, here is it in written form:</p>
<ul>
<li>First we check if it’s an application: if it is, we can evaluate it.
<ul>
<li>If both sides of the abstraction are values, we can simple replace all the ocurrences of <code data-astro-raw="">x</code> with the value being applied to the abstraction; (rule 3)</li>
<li>Otherwise, if the left-hand side is value, we evaluate right-hand side of the application; (rule 2)</li>
<li>If none of the above applies, we just evaluate the left-hand side of the application. (rule 1)</li>
</ul>
</li>
<li>Lastly, if no rules applies to the AST, that means that it’s already a value, and we are done reducing it.</li>
</ul>
<h2 id="63-de-bruijn-index">6.3 De Bruijn index</h2>
<p>The implementation of the <code data-astro-raw="">substitute</code> function uses the <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Bruijn index</a>, which assigns to every variable the distance between its occurrence and its definition.</p>
<p>For example, the following implementation of <code data-astro-raw="">true</code> and <code data-astro-raw="">false</code> (see <a href="https://en.wikipedia.org/wiki/Church_encoding">Church Encoding</a> for reference):</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λx. (λy. x)) (λf. (λg. g))</code></pre>
<p>becomes:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λx. (λy. 1)) (λf. (λg. 0))</code></pre>
<p>Note that the parameter names are no longer necessary, but I’ll keep them in order to highlight the indices, keeping everything else the same.</p>
<p>We can generate the indices during parsing, by augmenting the parser with a context, which will work as a stack of variable names. In order to find the De Bruijn index of a variable, we get its offset in the context stack.</p>
<p>Here are the main rules affected (the other ones will simply pipe the context variable through):</p>
<pre class="language-js"><code data-astro-raw="" class="language-js"><span class="token function">term</span><span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LAMBDA</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">token</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LCID</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">DOT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Push the parameter into the context stack when parsing the
     * abstraction's body (without mutating the current context)
     */</span>
    <span class="token keyword">const</span> term <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">term</span><span class="token punctuation">(</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AST<span class="token punctuation">.</span>Abstraction</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> term<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>

<span class="token function">atom</span><span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LCID</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lexer<span class="token punctuation">.</span><span class="token function">token</span><span class="token punctuation">(</span>Token<span class="token punctuation">.</span><span class="token constant">LCID</span><span class="token punctuation">)</span>
    <span class="token comment">// Use the builtin indexOf to get the distance in the stack</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AST<span class="token punctuation">.</span>Identifier</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="64-substitution">6.4 Substitution</h2>
<p>I personally find the substitution algorithm a little bit confusing, and that’s why I didn’t include it in the original version of the article, but I’ll try and do my best to explain it.</p>
<p>Substitute is actually in built on top of 2 operations: <code data-astro-raw="">shift</code> and the actual <code data-astro-raw="">subst</code>:</p>
<ul>
<li><code data-astro-raw="">shift(x, node)</code>: shifts all <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Free_variables">free variables</a> in <code data-astro-raw="">node</code> by <code data-astro-raw="">x</code>.</li>
<li><code data-astro-raw="">subst(value, node)</code>: substitutes all the variables in <code data-astro-raw="">node</code> that have a De Bruijn index of zero by <code data-astro-raw="">value</code>.</li>
</ul>
<h3 id="lets-look-at-a-step-by-step-example">Let’s look at a step by step example:</h3>
<ol>
<li>
<p>If we start with the following source:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λx. (λy. y x)) (λt. a)</code></pre>
</li>
<li>
<p>Assuming that <code data-astro-raw="">a</code> is a free variable that is one level above, it will look like the following with De Bruijn indices:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λx. (λy. 0 1)) (λt. 1)</code></pre>
</li>
<li>
<p>Now we evaluate using rule 3: we replace every variable pointing to <code data-astro-raw="">x</code> with <code data-astro-raw="">(λt. 1)</code>:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λy. 0 (λt. 1)))</code></pre>
</li>
<li>
<p>Can you spot the problem? <code data-astro-raw="">(λt. 1)</code> was originally referring to <code data-astro-raw="">a</code>, but after the substitution it refers to <code data-astro-raw="">y</code>.That happened because we moved <code data-astro-raw="">(λt. 1)</code> one level deeper than it was before, but didn’t update the free variables. For that reason substitution is defined as follows:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">↓([x ↦ ↑value] node)</code></pre>
<p><em>This means: shift down the result of replacing all occurrences of <code data-astro-raw="">x</code> in <code data-astro-raw="">node</code> with <code data-astro-raw="">value</code> shifted up.</em></p>
</li>
<li>
<p>Breaking it down:</p>
<p>5.1. First we shift the free variables in the value up by one:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λx. (λy. 0 1)) (λt. 2)</code></pre>
<p>5.2. Then we replace the occurrences of <code data-astro-raw="">x</code> with the new value:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λx. (λy. 0 (λt. 3)))</code></pre>
<p><em>notice that we bump the index that refers to <code data-astro-raw="">a</code> from <code data-astro-raw="">2</code> to <code data-astro-raw="">3</code>. That happens because every time we increase the depth of the node (by placing it inside a closure) we need to shift it by the depth difference, which is one in this case (it’s only inside one extra closure).</em></p>
<p>5.3 Then we drop the enclosing abstraction:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λy. 0 (λt. 3))</code></pre>
<p>5.4. And shift all the free variables down by one:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λy. 0 (λt. 2))</code></pre>
</li>
<li>
<p>Finally we just need to lookup the parameters’ names at the right offsets, and we get a proper output:</p>
<pre class="language-null"><code data-astro-raw="" class="language-null">(λy. y (λt. a))</code></pre>
</li>
</ol>
<h3 id="65-notes-on-substitution">6.5. Notes on substitution</h3>
<p>The substitution logic is recursive, so it requires implementing functions that visit the AST recursively. The full implementation includes an utility function for writing AST visitors and two visitors: <code data-astro-raw="">shift</code> and <code data-astro-raw="">subst</code>. The code for that is long and not very interesting, so I skipped it here, but it will be available at the end with the full implementation.</p>
<h2 id="7-printing">7. Printing</h2>
<p>We are almost done now: we can already reduce a program to a value, all we have left now is to implement the logic to print this value.</p>
<p>An easy way of doing that is by adding a <code data-astro-raw="">toString</code> method to every AST node, the only thing we have to be careful with is that we have to map the De Bruijn indices back to the original variable names, as shown in item 6 above.</p>
<p>Here’s the code:</p>
<pre class="language-javascript"><code data-astro-raw="" class="language-javascript"><span class="token comment">/* Abstraction */</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token parameter">ctx<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(λ</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>param<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">. </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>param<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* Application */</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>lhs<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>rhs<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* Identifier */</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> ctx<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>We know that the interpreter will reduce the program to a value, we also know that this value will be an AST node, and according to the evaluation rules the only value in λ-calculus is an abstraction. We can then conclude that the evaluation result will be an abstraction, and hence the default value for the context argument in the <code data-astro-raw="">Abstraction.toString</code> method, so we can call it from outside without providing a context.</p>
<p>Now we can just call <code data-astro-raw="">toString</code> in the resulting node, and it’ll print all of its children recursively (passing the context) in order to generate its string representation.</p>
<h2 id="8-putting-it-all-together">8. Putting it all together</h2>
<p>We’ll need a runner script that will wire all this parts together, the code should be something like:</p>
<pre class="language-javascript"><code data-astro-raw="" class="language-javascript"><span class="token comment">// assuming you have some source</span>
<span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token string">'(λx. λy. x) (λx. x) (λy. y)'</span><span class="token punctuation">;</span>

<span class="token comment">// wire all the pieces together</span>
<span class="token keyword">const</span> lexer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lexer</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parser</span><span class="token punctuation">(</span>lexer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> ast <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> Interpreter<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// stringify the resulting node and print it</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2 id="source-code">Source code</h2>
<p>The full implementation can be found on Github: <a href="https://github.com/tadeuzagallo/lc-js">github.com/tadeuzagallo/lc-js</a></p>
<h4 id="thats-all">That’s all!</h4>
<p>Thanks for reading, and as usual, any feedback is more than welcome! 😊</p>
        </div>

        <footer class="footer astro-ZRE6QY23">
          <section class="share astro-ZRE6QY23">
            <button class="share-button astro-ZRE6QY23" aria-label="Share on Twitter" title="Share on Twitter">
              <svg class="share-icon astro-ZRE6QY23" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg">
                <path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z" class="astro-ZRE6QY23"></path>
              </svg>
              <span class="astro-ZRE6QY23">Share on Twitter</span>
            </button>
          </section>

          <div id="disqus_thread" class="astro-ZRE6QY23"></div>

          <script data-title="A λ-calculus interpreter" data-slug="writing-a-lambda-calculus-interpreter-in-javascript" data-permalink="https://tadeuzagallo.com/blog/writing-a-lambda-calculus-interpreter-in-javascript/">
            const { title, slug, permalink } = document.currentScript.dataset;
            var disqus_config = function () {
              this.page.title = title;
              this.page.identifier = slug;
              this.page.url = permalink; 
            };
            (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://tadeuzagallo.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
            })();
          </script>
          <script data-twitterurl="https://twitter.com/intent/tweet?text=&quot;A λ-calculus interpreter in less than 300 lines of JavaScript&quot; https://tadeuzagallo.com/blog/writing-a-lambda-calculus-interpreter-in-javascript/ via @tadeuzagallo&amp;hashtags=interpreter,fp,javascript">
            const { twitterurl } = document.currentScript.dataset;
            document.querySelector('.share-button').addEventListener('click', e => {
              e.preventDefault();
              window.open(twitterurl, 'twitter-share', 'width=800,height=800');
            });
          </script>
        </footer>
      </div>
    </div>
  


</body></html>